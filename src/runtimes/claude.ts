// Claude Code runtime adapter for overstory's AgentRuntime interface.
// Pure extraction — no new behavior. All implementation delegates to existing code.
// Phase 0: file exists and compiles. Callers are not rewired until Phase 2.

import { mkdir } from "node:fs/promises";
import { join } from "node:path";
import { deployHooks } from "../agents/hooks-deployer.ts";
import { estimateCost, parseTranscriptUsage } from "../metrics/transcript.ts";
import type { ResolvedModel } from "../types.ts";
import type {
	AgentRuntime,
	HooksDef,
	OverlayContent,
	ReadyState,
	SpawnOpts,
	TranscriptSummary,
} from "./types.ts";

/**
 * Claude Code runtime adapter.
 *
 * Implements AgentRuntime for the `claude` CLI (Anthropic's Claude Code).
 * All methods delegate to existing overstory subsystems — this adapter
 * only provides the runtime-agnostic interface layer.
 *
 * Phase 0: file exists, compiles, and exports the class.
 * Phase 2 will rewire callers (sling.ts, coordinator.ts, etc.) to use this adapter.
 */
export class ClaudeRuntime implements AgentRuntime {
	/** Unique identifier for this runtime. */
	readonly id = "claude";

	/** Relative path to the instruction file within a worktree. */
	readonly instructionPath = ".claude/CLAUDE.md";

	/**
	 * Build the shell command string to spawn an interactive Claude Code agent.
	 *
	 * Maps SpawnOpts to the `claude` CLI flags:
	 * - `model` → `--model <model>`
	 * - `permissionMode` → `--permission-mode <mode>`
	 *   - "bypass" maps to "bypassPermissions"
	 *   - "ask" maps to "default"
	 * - `appendSystemPrompt` → `--append-system-prompt '<escaped>'`
	 *
	 * The returned string is passed directly to tmux as the initial command.
	 * The `cwd` and `env` fields of SpawnOpts are handled by the tmux session
	 * creator, not embedded in the command string.
	 *
	 * @param opts - Spawn options (model, permissionMode, appendSystemPrompt)
	 * @returns Shell command string suitable for tmux new-session -c
	 */
	buildSpawnCommand(opts: SpawnOpts): string {
		const permMode = opts.permissionMode === "bypass" ? "bypassPermissions" : "default";
		let cmd = `claude --model ${opts.model} --permission-mode ${permMode}`;

		if (opts.appendSystemPromptFile) {
			// Read from file at shell expansion time — avoids tmux IPC message size
			// limits (~8-16KB) that cause "command too long" errors when large agent
			// definitions are inlined. The $(cat ...) expands inside the tmux pane's
			// shell, so the tmux IPC message only carries the short command string.
			const escaped = opts.appendSystemPromptFile.replace(/'/g, "'\\''");
			cmd += ` --append-system-prompt "$(cat '${escaped}')"`;
		} else if (opts.appendSystemPrompt) {
			// Single-quote the content for safe shell expansion.
			// POSIX single-quoted strings cannot contain single quotes, so escape
			// them using the standard technique: end quote, escaped quote, start quote.
			const escaped = opts.appendSystemPrompt.replace(/'/g, "'\\''");
			cmd += ` --append-system-prompt '${escaped}'`;
		}

		return cmd;
	}

	/**
	 * Build the argv array for a headless one-shot Claude invocation.
	 *
	 * Returns an argv array suitable for `Bun.spawn()`. The `--print` flag
	 * causes Claude Code to run the prompt and exit, writing output to stdout.
	 *
	 * Used by merge/resolver.ts (AI-assisted conflict resolution) and
	 * watchdog/triage.ts (AI-assisted failure classification).
	 *
	 * @param prompt - The prompt to pass via `-p`
	 * @param model - Optional model override (omit to use Claude Code's default)
	 * @returns Argv array for Bun.spawn
	 */
	buildPrintCommand(prompt: string, model?: string): string[] {
		const cmd = ["claude", "--print", "-p", prompt];
		if (model !== undefined) {
			cmd.push("--model", model);
		}
		return cmd;
	}

	/**
	 * Deploy per-agent instructions and guards to a worktree.
	 *
	 * For Claude Code this means writes to the worktree's `.claude/` directory:
	 * 1. `CLAUDE.md` — the agent's task-specific overlay (generated by ov sling).
	 *    Skipped when overlay is undefined (hooks-only deployment for coordinator/supervisor/monitor).
	 * 2. `settings.local.json` — Claude Code hooks for security guards
	 *
	 * The `overlay.content` is written verbatim when provided. The hooks are generated by
	 * `deployHooks()` from `src/agents/hooks-deployer.ts`.
	 *
	 * @param worktreePath - Absolute path to the agent's git worktree
	 * @param overlay - Overlay content to write as CLAUDE.md, or undefined for hooks-only deployment
	 * @param hooks - Hook definition used by deployHooks
	 * @throws {AgentError} If the hooks template is missing or writes fail
	 */
	async deployConfig(
		worktreePath: string,
		overlay: OverlayContent | undefined,
		hooks: HooksDef,
	): Promise<void> {
		if (overlay) {
			const claudeDir = join(worktreePath, ".claude");
			await mkdir(claudeDir, { recursive: true });

			const claudeMdPath = join(claudeDir, "CLAUDE.md");
			await Bun.write(claudeMdPath, overlay.content);
		}

		await deployHooks(hooks.worktreePath, hooks.agentName, hooks.capability, hooks.qualityGates);
	}

	/**
	 * Detect Claude Code TUI readiness from a tmux pane content snapshot.
	 *
	 * Uses the same heuristics as `waitForTuiReady()` in `src/worktree/tmux.ts`,
	 * but operates on a pre-captured pane string rather than polling tmux directly.
	 * The caller is responsible for capturing pane content and acting on the result
	 * (e.g. sending "Enter" to dismiss a trust dialog).
	 *
	 * Detection phases:
	 * - Trust dialog: "trust this folder" detected → `{ phase: "dialog", action: "Enter" }`
	 * - Ready: prompt indicator (❯ or 'Try "') AND status bar ("bypass permissions"
	 *   or "shift+tab") both present → `{ phase: "ready" }`
	 * - Otherwise → `{ phase: "loading" }`
	 *
	 * @param paneContent - Captured tmux pane content to analyze
	 * @returns Current readiness phase
	 */
	detectReady(paneContent: string): ReadyState {
		// Trust dialog takes precedence — it replaces the normal TUI temporarily.
		// The caller should send the action key to dismiss it.
		if (paneContent.includes("trust this folder")) {
			return { phase: "dialog", action: "Enter" };
		}

		// Phase 1: prompt indicator confirms Claude Code has started.
		// ❯ is the claude prompt character; 'Try "' appears in the welcome banner.
		const hasPrompt = paneContent.includes("\u276f") || paneContent.includes('Try "');

		// Phase 2: status bar text confirms full TUI render.
		const hasStatusBar =
			paneContent.includes("bypass permissions") || paneContent.includes("shift+tab");

		if (hasPrompt && hasStatusBar) {
			return { phase: "ready" };
		}

		return { phase: "loading" };
	}

	/**
	 * Parse a Claude Code transcript JSONL file into normalized token usage.
	 *
	 * Reads the JSONL file at `path` and aggregates token usage across all
	 * assistant turns. Returns null if the file does not exist or cannot be read.
	 *
	 * Delegates to `parseTranscriptUsage()` and `estimateCost()` from
	 * `src/metrics/transcript.ts`. The `estimatedCostUsd` is computed but
	 * not exposed here because `TranscriptSummary` only carries the three
	 * core fields (inputTokens, outputTokens, model). Cost data is available
	 * via `src/metrics/transcript.ts` directly for callers that need it.
	 *
	 * @param path - Absolute path to the transcript JSONL file
	 * @returns Aggregated token usage, or null if unavailable
	 */
	async parseTranscript(path: string): Promise<TranscriptSummary | null> {
		const file = Bun.file(path);
		if (!(await file.exists())) {
			return null;
		}

		try {
			const usage = await parseTranscriptUsage(path);
			// estimateCost is called to validate the model is recognized,
			// though the result is not surfaced in TranscriptSummary.
			if (usage.modelUsed !== null) {
				estimateCost(usage);
			}
			return {
				inputTokens: usage.inputTokens,
				outputTokens: usage.outputTokens,
				model: usage.modelUsed ?? "",
			};
		} catch {
			return null;
		}
	}

	/**
	 * Build runtime-specific environment variables for model/provider routing.
	 *
	 * Returns the provider environment variables from the resolved model.
	 * For Anthropic native: may include ANTHROPIC_API_KEY, ANTHROPIC_BASE_URL.
	 * For gateway providers: may include gateway-specific auth and routing vars.
	 *
	 * Returns an empty object if the resolved model has no provider env vars.
	 * Callers (sling.ts, coordinator.ts) merge this with OVERSTORY_AGENT_NAME
	 * and OVERSTORY_WORKTREE_PATH before passing to createSession().
	 *
	 * @param model - Resolved model with optional provider env vars
	 * @returns Environment variable map (may be empty)
	 */
	buildEnv(model: ResolvedModel): Record<string, string> {
		return model.env ?? {};
	}
}

/** Singleton instance for use in callers that do not need DI. */
export const claudeRuntime = new ClaudeRuntime();
